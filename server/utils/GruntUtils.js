/**
 * Created by hunter.novak on 10/12/14.
 */
'use strict';

var fs    = require('fs'),
    path  = require('path'),
    _     = require('lodash');


function getJsSourceMap(scriptFolders, distDir) {
  var output = {};

  _.each(scriptFolders, function(folderPath) {
    var finder = require('findit')(folderPath);

    finder.on('file', function(filePath) {
      if (filePath.match(/.js$/)) {
        var targetFile = path.join(distDir, filePath);
        output[targetFile] = filePath;
      }
    });
  });

  return output;
}

function generateComponentSass(workingDir, sassPath, componentPath, fileName) {
  var componentsFile        = path.join(sassPath, fileName);
  var componentsPath        = path.join(workingDir, componentPath);
  var pageComponentsSubPath = path.join(componentsPath, 'pages');
  var bbComponentsSubPath   = path.join(componentsPath, 'building-blocks');
  var pageComponentFiles    = fsSearchTree(pageComponentsSubPath, '.+\\.scss', true);  // find any scss files, recursively
  var bbComponentFiles      = fsSearchTree(bbComponentsSubPath, '.+\\.scss', true);    // find any scss files, recursively
  var orderedComponentFiles = pageComponentFiles.concat(bbComponentFiles);
  pageComponentFiles        = null;
  bbComponentFiles          = null;

  var globComponentsSource  = '/* This file is autogenerated.  Do not edit. */\n';
  orderedComponentFiles.forEach(function(componentFilePath,idx) {
    var pathToComponent     =   path.relative(sassPath, componentFilePath);
    globComponentsSource    +=  '@import \'' + pathToComponent + '\';\n';
  });

  globComponentsSource      += '/* END. Generated on ' + new Date().toString() + ' */\n';
  globComponentsSource      += '/* See grunt task \'glob-components\' for more. */\n';

  var finalRelativePath     = path.relative(workingDir, componentsFile);
  var gotError              = fs.writeFileSync(componentsFile, globComponentsSource, { flag: 'w', mode: 429 });  // chmod 655

  if (!gotError) {
    console.log('Interim components glob file [\x1b[0;36m%s\x1b[0;0m] created.', finalRelativePath);
    return true;
  }

  console.error('\x1b[1;31mUnable to produce glob file: [%s].\x1b[0;0m', finalRelativePath);
  return false;
}

function trackChanges(changedFiles, action, filepath, target, majorChangeCallback, minorChangeCallback) {
  var restartRequired = false;

  var addChangedEntry = function(fpath, act, changeObj, type, regexCheck) {
    if (regexCheck.test(fpath)) {
      changeObj[type] = changeObj[type] || {};
      restartRequired = true;

      var changeName = fpath.replace(regexCheck, '$2');
      var changePath = fpath.replace(regexCheck, '$1');
      changeObj[type][changeName] = { path: changePath, action: act };
    }
  };

  // COMPONENT
  addChangedEntry(filepath, action, changedFiles, 'components', /^(client\/src\/components\/[^\/]+)\/([^\/]+)\/.*$/);
  addChangedEntry(filepath, action, changedFiles, 'services', /^(client\/src\/services\/.*?([^\/]+).js)$/);
  addChangedEntry(filepath, action, changedFiles, 'behaviors', /^(client\/src\/behaviors\/([^\/]+)\/.*.js)$/);

  if (restartRequired) {
    if (majorChangeCallback) {
      majorChangeCallback();
    }
  } else {
    if (minorChangeCallback) {
      minorChangeCallback();
    }
  }
}


function fsReadTreeSync(buffer, tree, matchExp, recurse) {
  recurse = !!recurse;
  if (!buffer || !('length' in buffer)) {
    console.log("error: no deposit stack to work with :-(");
    return;
  }

  function processFile(file) {
    var filenameExt = path.basename(file);
    var ext = path.extname(filenameExt);

    // matches filenames, not paths
    if (filenameExt.match(matchExp)) {
      buffer.push(file);
    }
  }

  // console.log('Reading:', tree);

  var stat = fs.lstatSync(tree);

  if (stat.isFile()) {
    processFile(tree);

  } else if (stat.isDirectory()) {

    var folderContents = fs.readdirSync(tree);
    folderContents.forEach(function(item, index) {

      var itemtree = path.join(tree, item);
      stat = fs.lstatSync(itemtree);

      if (stat.isFile()) {
        processFile(itemtree);
      }

      else if (recurse) {
        fsReadTreeSync(buffer, itemtree, matchExp, recurse);
      }
    });
  }
  else {
    return null; // tree is not file or dir.  probably a symlink..
  }

}


function fsSearchTree(tree, strmatch, recurse) {
  recurse = !!recurse;
  var matchExp = new RegExp(strmatch, 'i');

  console.log('Traversing:', tree)

  if (!fs.existsSync(tree)) {
    console.log('DOES NOT EXIST:', tree);
    return null; // failed to find tree
  }
  var buffer = [];
  fsReadTreeSync(buffer, tree, matchExp, recurse);

  return buffer;
}

module.exports = {
  generateComponentSass:  generateComponentSass,
  getJsSourceMap:         getJsSourceMap,
  trackChanges:           trackChanges,
  fsSearchTree:           fsSearchTree
};